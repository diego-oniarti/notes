\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{semantic}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{nicefrac, xfrac}
\usepackage[a4paper, margin=0.5in]{geometry}
\usepackage{setspace}

\input{../common}
\newcommand{\execs}[0]{\ensuremath{\rightrightarrows}}

\usepackage{pdflscape}

\title{Assignment \#4}
\author{Diego Oniarti - 257835}
\date{}
\begin{document}
\maketitle

\section{Progress}
Write the proof for the progress theorem for the cases related to locations, allocations, dereferencing, and update.
\begin{esempio}{Progress}
    $\IF H:\Sigma\AND\Sigma,\emptyset,\emptyset\vdash  t:\tau \THEN \text{either } \vdash t.VAL \OR \exists t',H'.H\triangleright t \leadsto H'\triangleright t'$ \\
    Proven by induction
\end{esempio}
\begin{enumerate}
    \item locations
        \begin{align*}
            \text{w.h.} &\ H:\Sigma \AND \Sigma,\emptyset,\emptyset\vdash l:ref(\tau) \\
            \text{t.s.} &\ 
            \begin{array}{ll}
                \text{either}  & \vdash l.VAL \\
                \text{or}  & \exists t',H'. H\triangleright l \leadsto H'\triangleright t'
            \end{array} \\
            \text{by def.} &\ l.val_\square
        \end{align*}
    \item allocation
        \begin{align*}
            \text{w.h.} &\ H:\Sigma\AND \Sigma,\emptyset,\emptyset\vdash \NEW v: ref(\tau)
        \end{align*}
    \item dereferencing
    \item update
\end{enumerate}

\section{Program equivalence}
For each of these programs, tell if they are equivalent or not. If they are equivalent, show what they reduce to, no matter the input. If they are not, argue why and if possible, show a context that tells them apart.
\begin{enumerate}
    \item
        \begin{itemize}
            \item $z:Ref(\N\to\N)$
            \item $t_1=\lam{x:\N}{!z\ 0;2+x}$
            \item $t_2=\lam{x:\N}{\IF x>0 \THEN x+2 \ELSE !z\ x;x+2}$
        \end{itemize}
        Not equivalent. Let's say we have a context where we set a value to $0$ and define $z$ to override that value with$1$. Applying $t_1$ and $t_2$ to $0$ and reading the value we set in the beginning would give us different outcomes.
    \item 
        \begin{itemize}
            \item $t_1= \LET x=\lam{y:\forall\alpha.\alpha\to\alpha}\lam{z:\N}{y[\N]\ (z+1)} \TIN x$
            \item $t_2= \lam{y:\forall\alpha.\alpha\to\alpha}\lam{x:\N}{(y[\N]\ x)+1}$
        \end{itemize}
        Not equivalent

    \item 
        \begin{itemize}
            \item $f:(Ref\ \N)\to\N$
            \item $t_1=\LET x= new\ 0 \TIN f\ x; !x$
            \item $t_2=\LET x= new\ 1\ \TIN f\ (new\ 0); x:=(!x-1)$
        \end{itemize}
\end{enumerate}

\section{A private memory for ASM}
Add a private memory to ASM. The domain of the memory becomes integers, so positive and negative numbers. Negative integers represent a private memory. \\
Modify the semantics of ASM to reflect the following access control policy:
If the program counter is within the address range $0$ to $100$, then any read or write to the private memory succeeds, otherwise any read or write returns $0$.

\section{Labelled ASM Functions}
Add named functions to ASM. ASM programs become a list mapping names to codebases. ASM instructions now include
\begin{enumerate}
    \item calling a function whose name is statically known
    \item calling a function by jumping to the address where it starts (the address value is read from a register)
    \item returning from a called function
\end{enumerate}


\end{document}
