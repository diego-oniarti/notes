\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{semantic}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{nicefrac, xfrac}
\usepackage[a4paper, margin=0.5in]{geometry}
\usepackage{setspace}

\input{../common}
\newcommand{\execs}[0]{\ensuremath{\rightrightarrows}}

\usepackage{pdflscape}

\title{Assignment \#4}
\author{Diego Oniarti - 257835}
\date{}
\begin{document}
\maketitle

\section{Progress}
Write the proof for the progress theorem for the cases related to locations, allocations, dereferencing, and update.
\begin{esempio}{Progress}
    $\IF H:\Sigma\AND\Sigma,\emptyset,\emptyset\vdash  t:\tau \THEN \text{either } \vdash t.VAL \OR \exists t',H'.H\triangleright t \leadsto H'\triangleright t'$ \\
    Proven by induction
\end{esempio}
\begin{enumerate}
    \item locations
        \begin{align*}
            \text{w.h.} &\ H:\Sigma \AND \Sigma,\emptyset,\emptyset\vdash l:ref(\tau) \\
            \text{t.s.} &\ 
            \begin{array}{ll}
                \text{either}  & \vdash l.VAL \\
                \text{or}  & \exists t',H'. H\triangleright l \leadsto H'\triangleright t'
            \end{array} \\
            \text{by def.} &\ l.val_\square
        \end{align*}
    \item allocation
        \begin{align*}
            \text{w.h.} &\ H:\Sigma\AND \Sigma,\emptyset,\emptyset\vdash \NEW t_0: ref(\tau) \\
            \text{by IH w.h.} &\ \IF H_0:\Sigma_0 \AND \Sigma_0,\emptyset,\emptyset\vdash t_0:\tau \THEN \text{either } \textcolor{blue}{t_0.val} \OR \textcolor{purple}{\exists t_0',H_0'. H_0\triangleright t_0 \leadsto H_0'\triangleright t_0'} \\
            \text{case $\textcolor{blue}{t_0.val}$:} &\ H\triangleright\NEW t_0 \leadsto H,l\mapsto t_0\triangleright l \square \\
            \text{case $\textcolor{purple}{\exists t_0',H_0'. H_0\triangleright t_0 \leadsto H_0'\triangleright t_0'}$:} &\ H\triangleright\NEW t_0 \leadsto H\triangleright \NEW t_0' \square \\
        \end{align*}
    \item dereferencing
    \item update
\end{enumerate}

\section{Program equivalence}
For each of these programs, tell if they are equivalent or not. If they are equivalent, show what they reduce to, no matter the input. If they are not, argue why and if possible, show a context that tells them apart.
\begin{enumerate}
    \item
        \begin{itemize}
            \item $z:Ref(\N\to\N)$
            \item $t_1=\lam{x:\N}{!z\ 0;2+x}$
            \item $t_2=\lam{x:\N}{\IF x>0 \THEN x+2 \ELSE !z\ x;x+2}$
        \end{itemize}
        Not equivalent. Can be distinguished by this context:
        \begin{align*}
            & \LET d = \NEW 0 \TIN\\
            & \LET z = \lam{x:\N}{d:=1;12} \TIN\\
            &\ t_{1/2}\ 0; \IF !d == 0 \THEN 0 \ELSE \omega
        \end{align*}
    \item 
        \begin{itemize}
            \item $t_1= \LET x=\lam{y:\forall\alpha.\alpha\to\alpha}\lam{z:\N}{y[\N]\ (z+1)} \TIN x$
            \item $t_2= \lam{y:\forall\alpha.\alpha\to\alpha}\lam{x:\N}{(y[\N]\ x)+1}$
        \end{itemize}
        % Not equivalent
        % \begin{align*}
        %     & \LET d = \NEW 0 \TIN \\
        %     &\ t_{1/2}\ (\Lambda \alpha.\lam{x:\alpha}{d:=x;x})\ 0; \\
        %     & \IF !d == 0 \THEN 0 \ELSE \omega
        % \end{align*}
        Equivalent. In both cases the function passed to $t$ is an identity function, and we can't differentiate the two since they both return the input increased by $1$.

    \item 
        \begin{itemize}
            \item $f:(Ref\ \N)\to\N$
            \item $t_1=\LET x= new\ 0 \TIN f\ x; !x$
            \item $t_2=\LET x= new\ 1\ \TIN f\ (new\ 0); x:=(!x-1)$
        \end{itemize}

    \item 
        \begin{itemize}
            \item $r:Ref(\N)$
            \item $t_1=\left|\begin{array}{l}\LET x=!r \TIN\\ \LET y=\NEW x \TIN\\\ r:=!y;\\\ !y\end{array}\right.$
            \item $t_2=\left|\begin{array}{l}\LET x=\NEW 0 \TIN \\ \LET y=!x;!r \TIN\\\ y\end{array}\right.$
        \end{itemize}
\end{enumerate}

\section{A private memory for ASM}
Add a private memory to ASM. The domain of the memory becomes integers, so positive and negative numbers. Negative integers represent a private memory. \\
Modify the semantics of ASM to reflect the following access control policy:
If the program counter is within the address range $0$ to $100$, then any read or write to the private memory succeeds, otherwise any read or write returns $0$.

\section{Labelled ASM Functions}
Add named functions to ASM. ASM programs become a list mapping names to codebases. ASM instructions now include
\begin{enumerate}
    \item calling a function whose name is statically known
    \item calling a function by jumping to the address where it starts (the address value is read from a register)
    \item returning from a called function
\end{enumerate}


\end{document}
